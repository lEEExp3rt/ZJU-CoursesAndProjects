# <center> PROJECT3: Dijkstra Sequence
  
# <center>Date: 2023-11-24<center>

# <center>Author: lqy<center>

<div style="page-break-after: always"></div>

---

## Chapter1: Introduction

### Problem Description

In graph theory, a typical problem is that find the shortest path from the source vertex to the destination vertex for a given graph. There are several ways to solve this problem.

For solving this single source shortest path problem, one famous algorithm is ***Dijkstra Algorithm***. This is one typical greedy algorithm, which obtains the shortest path by selecting its source vertex's adjcent vertices with minimum distance and not included in the path in each step. Step by step, a shortest path will be generated using ***Dijkstra Algorithm***.

So our task is to find out whether a given sequence of vertices is a Dijkstra sequence.

### Input && Output Specification

In this problem, input and output are specified below:

#### Input

First line includes the two arguments: $N_v$ representing the number of vertices and $N_e$ representing the number of edges.

Then $N_e$ lines follow describing each edge in the graph, with source to destination and the weight of the edge.

Then comes $K$ test cases, each representing one sequence to be judged whether they are the shortest path.

It is guaranteed that the given graph is connected.

#### Output

Print `Yes` or `No` for each test case, with each one in a single line.

---

## Chapter2: Algorithm Specification

For this problem, we need to judge whether a given sequence satisfies the Dijkstra sequence, which is generated by the Dijkstra algorithm.

The Dijkstra algorithm can be implemented as follows:

```dotnetcli{.line-numbers}
pseducode: Dijkstra(Graph, SourceVertex):
    for (i := 1 to n):
        Distance[i] = infty
    Distance[SourceVertex] = 0
    Initialize(Set) = empty    
    for (every v in G):
        v := FindMinDistance(SourceVertex)
        AddToSet(v)
        for (every u not in Set):
            if (Distance[v] + weight(u,v) < Distance[u]):
                Distance[u] = Distance[v] + weight(u,v)
    return Distance
```

So thic checking process is a reverse version of the Dijkstra algorithm.

For each given test case, we scan the sequence one by one.

We divide the sequence into two sets, one for vertices already checked and one for not checked. First the first set is empty, and we scan the first vertex into the first set. Then we scan the next one and check whether the shortest path. 

* If the vertex being checked is within the shortest distance from the source vertex, then this vertex is correct. Next one.
* If the vertex being checked is not within the shortest distance from the source vertex, then this means there exists one or more vertices which is closer to the source is not included in the sequence, that means this sequence is not a correct one so the answer is `No`.

If the sequence check keeps going and the whole sequence is scanned, then the check process is finished and the answer is `Yes`.

```dotnetcli{.line-numbers}
pseudocode: IsDijkstraSequence(Graph G, int Sequence[]):
    int distancetosource[] = (G)
    for (every v in Sequence):
        if (v in distancetosource) check(v)=true
        if (v not in distancetosource && !check(v)) return false
    return true
```

---

## Chapter3: Testing Results

### Simplest Test Case

This test case is the simplest graph with only 2 vertices and 1 edge.

```bash{.line-numbers}
root@localhost ~$ gcc project3.c -w -o project3.exe
root@localhost ~$ ./project3.exe
2 1
1 2 1
2
1 2
2 1
Yes
Yes
```

### Graph Shaped in Cycle With Equal Weight

This test case constructs a graph which is shaped in a cycle and each vertices are equal weight.

```bash{.line-numbers}
root@localhost ~$ gcc project3.c -w -o project3.exe
root@localhost ~$ ./project3.exe
4 4
1 2 1
2 3 1
3 4 1
4 1 1
3
1 2 3 4
1 4 2 3
1 3 2 4
No
Yes
No
```

### Graph Shaped in Cycle With Inequal Weight

This test case constructs a graph which is shaped in a cycle and each vertices are not all equal weight.

```bash{.line-numbers}
root@localhost ~$ gcc project3.c -w -o project3.exe
root@localhost ~$ ./project3.exe
4 4
1 2 2
2 3 1
3 4 1
4 1 1
4
1 2 3 4
1 4 2 3
1 4 3 2
1 3 2 4
No
Yes
Yes
No
```

### Random Data 

This case makes random graph data. By using Python as a random data generator, we can easily get random data. The generator code will be put in the Appendix.

```bash{.line-numbers}
root@localhost ~$ gcc project3.c -w -o project3.exe
root@localhost ~$ ./project3.exe
10 20
10 1 4
4 9 10
2 7 80
10 10 9
2 5 11
7 11 77
7 6 88
11 5 59
10 2 40
7 8 3
4 10 19
3 7 58
9 8 74
3 1 24
8 7 64
8 9 38
5 9 83
8 9 79
9 5 51
1 2 69
7
2 4 3 9 8 10 6 5 1 7
4 9 10 3 6 5 8 2 1 7
7 1 10 3 8 9 2 6 4 5
10 7 8 5 1 3 6 2 4 9
5 6 10 8 7 1 2 4 3 9
3 2 9 5 1 6 4 10 8 7
7 6 8 3 4 5 2 10 9 1
```

### Test Case From PTA

```bash{.line-numbers}
root@localhost ~$ gcc project3.c -w -o project3.exe
root@localhost ~$ ./project3.exe
5 7
1 2 2
1 5 1
2 3 1
2 4 1
2 5 2
3 5 1
3 4 1
4
5 1 3 4 2
5 3 1 2 4
2 3 4 5 1
3 2 1 5 4
Yes
Yes
Yes
No
```

---

## Chapter4: Analysis and Comments

### Complexity

For each test case, the time complexity can be $O(N_v)$ as the opeartion `AddEdge` contributes $O(N_v)$, `distance` contributes $O(N_v)$ to construct the distance from every vertices to the source vertex, `IsDijkstraSequence` which is the key part of the algorithm contributes $O(N_v^2)$.

So the total time complexity of $K$ test cases is $O(K\times N_v)$

As for space complexity, this algorithm takes no recursion process and only some array and structure are used to store data, so for each test case, the space complexity is $O(N_v)$, that is, the total space complexity is $O(K\times N_v)$

### Improvement

For this algorithm there still exist several improvement waiting to be further improved, such as checking if the sequence vertex is among the closest distance.

---

## Appendix: Source Code

### zyy2023_3220103373_P3.py

```python{.line-numbers}
#!/usr/bin/python3
import random
v, e = input().split()
v = int(v)
e = int(e)
vlist = [i for i in range(1, v + 1)]
for j in range(e):
    v1 = random.randint(1, v + 1)
    v2 = random.randint(1, v + 1)
    weight = random.randint(1, 101)
    print("{} {} {}".format(v1, v2, weight))
k = int(input())
for _ in range(k):
    li = [s for s in range(1, v + 1)]
    random.shuffle(li)
    print(" ".join(str(item) for item in li))
```

### zyy2023_3220103373_P3.c

```c{.line-numbers}
#include<stdio.h>
#include<stdlib.h>

#define INFTY 100
#define MaxV 1000

typedef struct {
    int Vertex;
    int Weight;
    struct Vnode* Next; 
}Vnode; // Use adjacent list to implement the graph structure.

typedef struct {
    int length; // Number
    int vertex[MaxV];
}ShortestPath; // Record the shortest path.

void AddEdge(Vnode* V[], int v1, int v2, int weight) // Add edges between V1 and V2.
{
    Vnode* tmp1 = (Vnode*)malloc(sizeof(Vnode));
    tmp1->Vertex = v2;
    tmp1->Weight = weight;
    tmp1->Next = V[v1 - 1];
    V[v1 - 1] = tmp1;
    Vnode* tmp2 = (Vnode*)malloc(sizeof(Vnode));
    tmp2->Vertex = v1;
    tmp2->Weight = weight;
    tmp2->Next = V[v2 - 1];
    V[v2 - 1] = tmp2;
    return ;
}

void distance(Vnode* V[], int d[], int Source, int size) // returns the distance between the source and every other vertices.
{
    int queue[size], checked1[size],checked2[size];
    int front = 0, rear = -1;
    for (int i = 0; i < size; i++) // Initialize the distance.
    {
        d[i] = INFTY;
        checked1[i] = checked2[i] = 0;
    }
    d[Source - 1] = 0;
    queue[++rear] = Source; // Enqueue the first.
    checked1[Source - 1] = checked2[Source - 1] = 1; 
    while (front != size) // BFS the graph.
    {
        Vnode* tmp = V[queue[front] - 1];
        while (tmp != NULL)
        {
            if (!checked1[tmp->Vertex - 1]) // Omit the checked vertices.
            {
                if (!checked2[tmp->Vertex - 1]) // If the vertex is in the queue, not enqueue again.
                {
                    queue[++rear] = tmp->Vertex;
                    checked2[tmp->Vertex - 1] = 1; // In the queue.
                }
                if (d[queue[front] - 1] + tmp->Weight < d[tmp->Vertex - 1]) // Update the minimum distance by Dijkstra algorithm.
                {
                    d[tmp->Vertex - 1] = d[queue[front] - 1] + tmp->Weight;
                }
            }
            tmp = tmp->Next; // Next adjacent vertex.
        }
        checked1[queue[front] - 1] = 1; // Checked.
        front++; // Dequeue.
    }
    return ;
}

int IsDijkstraSequence(Vnode *V[], int distance[], int Sequence[], int size) // Check if the vertex is within the closest distance.
{
    int checked[size]; // Record if the ith vertex with index i-1 is checked.
    for (int i = 0; i < size;i++) checked[i] = 0; // Initialize.
    for (int Sequenceindex = 1; Sequenceindex < size; Sequenceindex++) // Scan the sequence.
    {
        ShortestPath* minvertex = (ShortestPath*)malloc(sizeof(ShortestPath)); // A set of not included vertices with closest distance.
        minvertex->length = 0; // Initialize.
        int mindistance = INFTY;
        /* First find out the closeset ones. */
        for (int vertex = 1; vertex <= size; vertex++) // Check all the vertex's distance and find out the closest ones.
        {
            if (vertex == Sequence[0]) continue; // Omit the source vertex.
            if (!checked[vertex - 1] && distance[vertex - 1] < mindistance) // Find a closer vertex.
            {
                mindistance = distance[vertex - 1]; // Update the distance.
                minvertex->length = 1; // Clear the set.
                minvertex->vertex[0] = vertex; 
            }
            else if (!checked[vertex - 1] && distance[vertex - 1] == mindistance) // Add one.
            {
                minvertex->vertex[minvertex->length++] = vertex;
            }
            // Omit the already checked ones.
        }
        /* Second check if the vertex is among the closest ones. */
        int flag = 0;
        for (int i = 0; i < minvertex->length; i++)
        {
                if (Sequence[Sequenceindex] == minvertex->vertex[i])
            {
                flag = 1;
                checked[Sequence[Sequenceindex] - 1] = 1; // Satisfied.
                break;
            }
        }
        if (!flag) return 0;
    }
    return 1;
}

int main()
{
    int v,e;
    scanf("%d %d",&v,&e);
    Vnode* vertex[v];
    for (int i = 0; i < v; i++) vertex[i] = NULL; // Initialize the graph.
    for (int i = 0; i < e; i++)
    {
        int v1,v2,weight;
        scanf("%d %d %d",&v1,&v2,&weight); // Read the edge data.
        AddEdge(vertex,v1,v2,weight); // Add the edge into the graph.
    }
    int K;
    scanf("%d",&K);
    int ans[K]; // Store the answer for each test case, 1 representing true while 0 representing false.
    for (int i = 0; i < K; i++) // K test cases.
    {
        int sequence[v];
        for (int j = 0; j < v; j++) // Read the sequence data.
        {
            scanf("%d",&sequence[j]);
        }
        int d[v];
        distance(vertex, d, sequence[0], v);
        ans[i] = IsDijkstraSequence(vertex, d, sequence, v);
    }
    for (int i = 0; i < K; i++) // Print out the answer.
    {
        ans[i]? printf("Yes\n"): printf("No\n");
    }
    return 0;
}
```

---

## Declaration

*I hereby declare that all the work done in this project titled "zyy2023_3220103373_P3" is of my independent effort.*